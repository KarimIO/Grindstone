#version 140

in vec2 UV;
out float SSAOout;

const int kernelSize = 64;
const float radius = 1.2;

uniform mat4 projection;
uniform sampler2D gbuffer0;
uniform sampler2D gbuffer1;
uniform sampler2D noiseTex;
uniform vec3 kernels[kernelSize];

#include ../shaders/common/inc_transform.glsl

const vec2 noiseScale = vec2(1366.0/4.0, 768.0/4.0);

const float near = 0.1;
const float far = 100.0;

float LinearizeDepth(float depth)
{
    float z = depth * 2.0 - 1.0; // back to NDC 
    return (2.0 * near * far) / (far + near - z * (far - near));    
}

vec3 ViewNormal(vec3 inNorm) {
    return (transpose(invViewMat) * normalize(vec4(inNorm, 1.0))).rgb;
}

vec3 viewPositionFromDepth(vec2 vTexCoord)
{
    float z = texture2D(gbuffer0, vTexCoord).r;
    
    float x = vTexCoord.x * 2.0 - 1.0;
    float y = vTexCoord.y * 2.0 - 1.0;
    vec4 vProjectedPos = vec4(x, y, z, 1.0f);
    
    vec4 vPositionVS = invProjMat*vProjectedPos;
    
    return vPositionVS.xyz / vPositionVS.w;
}

void main() {
    vec4 gbuffer1Val = texture(gbuffer1, UV);

    vec3 fragPos    = viewPositionFromDepth(UV);
    vec3 normal     = ViewNormal(decodeNormal(gbuffer1Val.rgb));
    vec3 randomVec  = vec3(2 * texture(noiseTex, UV * noiseScale).rg - 1, 0); 

    vec3 tangent   = normalize(randomVec - normal * dot(randomVec, normal));
    vec3 bitangent = cross(normal, tangent);
    mat3 TBN       = mat3(tangent, bitangent, normal);

    float bias = 0.025;
    float occlusion = 0.0;

    for(int i = 0; i < kernelSize; i++) {
        vec3 sampleKernel = TBN * kernels[i];
        sampleKernel = fragPos + sampleKernel * radius;

        vec4 offset = vec4(sampleKernel, 1.0);
        offset      = projection * offset;    // from view to clip-space
        offset.xyz /= offset.w;               // perspective divide
        offset.xyz  = offset.xyz * 0.5 + 0.5; // transform to range 0.0 - 1.0

        float sampleDepth = viewPositionFromDepth(offset.xy).z;
        float rangeCheck = smoothstep(0.0, 1.0, radius / abs(fragPos.z - sampleDepth));
        occlusion += (sampleDepth >= sampleKernel.z + bias ? 1.0 : 0.0) * rangeCheck;
    }

    occlusion = 1.0 - (occlusion / kernelSize);
    SSAOout = occlusion;
}
include "$GRINDSTONE.RENDERER.DEFERRED/deferredPipeline/lightingTemplate.gpset"

pipelineSet "Spot Light" inherits "DeferredLighting" {
	configuration "main" {
		pass "main" {
			shaderEntrypoint: vertex mainVertex
			shaderEntrypoint: fragment mainFragment

			requiresBlocks [
				GsRendererUniform,
				CommonConstants,
				BSDF,
				LightGbufferUniforms,
				DiffuseDisney,
				GsComputeWorldSpacePosition
			]

			shaderHlsl {
				struct LightUbo {
					float4x4 shadowMatrix;
					float3 color;
					float attenuationRadius;
					float3 position;
					float intensity;
					float3 direction;
					float innerAngle;
					float outerAngle;
					float shadowResolution;
				};

				ConstantBuffer<LightUbo> light : register(b0, space2);
				Texture2D<float4> shadowMap : register(t1,  space2);

				float3 LightPointCalc(
					in float3 albedo,
					in float3 position,
					in float3 specularTexture,
					in float roughness,
					in float3 normal,
					in float3 lightPos,
					in float lightRadius,
					in float3 lightColor,
					in float3 eyePos
				) {
					float3 lightDir	= position - lightPos;
					float lightDistance	= length(lightDir);

					float3 eyeDir		= normalize(eyePos - position);
					float3 eyeReflect = reflect(-eyeDir, normal);

					lightDir		= -normalize(lightDir);

					float alpha = roughness * roughness;
					float alphaSqr = alpha * alpha;

					float NL = clamp(dot(normal, lightDir), 0, 1);

					float distSqr = lightDistance * lightDistance;
					float lightRadiusSqr = lightRadius * lightRadius;
					float attenuationFactor = distSqr / lightRadiusSqr;
					float attenuation = clamp(1 - attenuationFactor * attenuationFactor, 0, 1);
					attenuation = attenuation * attenuation / (distSqr + 0.001);

					float3 H = normalize(eyeDir + lightDir);

					float NV = abs(dot(normal, eyeDir)) + 0.00001;
					float NH = clamp(dot(normal, H), 0, 1);
					float LH = clamp(dot(lightDir, H), 0, 1);
					float VH = clamp(dot(eyeDir, H), 0, 1);

					float3 specular = BSDF(NV, NL, LH, NH, alpha, specularTexture.rgb);
					float diffDisney = DiffuseDisney(NV, NL, LH, roughness);
					float3 diffuse = albedo.rgb * float3(diffDisney, diffDisney, diffDisney) / PI;

					float3 lightModifier = lightColor.xyz * attenuation;
					float3 BSDFValue = diffuse + specular;
					return float3(NL * BSDFValue * lightModifier);
				}

				float4 mainFragment(VertexToFragment input) : SV_TARGET0 {
					float4 gbufferSpecularRoughnessValue = gbufferSpecularRoughness.Sample(gbufferSampler, input.scaledFragmentTexCoord);

					float depth = gbufferDepth.Sample(gbufferSampler, input.scaledFragmentTexCoord).r;
					float3 position = ComputeWorldSpacePosition(rendererUbo.inverseProjectionMatrix, rendererUbo.inverseViewMatrix, input.fragmentTexCoord, depth);
					float3 albedo = gbufferAlbedo.Sample(gbufferSampler, input.scaledFragmentTexCoord).rgb;
					float3 normal = gbufferNormals.Sample(gbufferSampler, input.scaledFragmentTexCoord).rgb;
					float3 specular = gbufferSpecularRoughnessValue.rgb;
					float roughness = gbufferSpecularRoughnessValue.a;

					float3 lightPow = light.color * light.intensity;

					float3 lightDir = normalize(position - light.position);
					float3 lightDirection = light.direction;

					float maxDot = light.innerAngle;
					float minDot = light.outerAngle;
					float diffDot = maxDot - minDot;
					float dotPR = dot(lightDir, lightDirection);
					dotPR = clamp((dotPR - minDot) / diffDot, 0, 1);

					float3 litValues = max(
						LightPointCalc(
							albedo,
							position,
							specular,
							roughness,
							normal,
							light.position,
							light.attenuationRadius,
							lightPow,
							rendererUbo.eyePos
						) * dotPR,
						0.0f
					);

					float nl = dot(lightDirection, normal);

					position.y += 1.0f;
					float4 lightSpacePos = mul(light.shadowMatrix, float4(position, 1));
					float3 projCoords = lightSpacePos.xyz / lightSpacePos.w;
					float pixelDepth = projCoords.z;

					float bias = 0.005;
					float closestDepth = shadowMap.Sample(gbufferSampler, projCoords.xy).x;

					bool isInMap = projCoords.x >= 0 && projCoords.x <= 1 && projCoords.y >= 0 && projCoords.y <= 1 && projCoords.z >= 0 && projCoords.z <= 1;
					bool isInLight = closestDepth + bias >= pixelDepth;
					float isInLightMap = (isInMap && isInLight) ? 1.0f : 0.0f;

					return float4(isInLightMap * litValues, 1);
				}
			}
		}
	}
}

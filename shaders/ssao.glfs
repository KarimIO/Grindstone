#version 410 core

in vec2 UV;
in vec4 vRay;
out float output;

const int kernelSize = 64;

uniform mat4 projection;
uniform sampler2D gbuffer0;
uniform sampler2D gbuffer1;
uniform sampler2D gbuffer2;
uniform sampler2D gbuffer3;
uniform sampler2D noiseTex;
uniform vec3 kernels[kernelSize];

#include ../shaders/decode.is

const vec2 noiseScale = vec2(1366.0/4.0, 768.0/4.0);

const float near = 0.1;
const float far = 100.0;

float LinearizeDepth(float depth)
{
    float z = depth * 2.0 - 1.0; // back to NDC 
    return (2.0 * near * far) / (far + near - z * (far - near));    
}

void main() {
	vec4 gbuffer0Val = texture(gbuffer0, UV);
	vec4 gbuffer1Val = texture(gbuffer1, UV);
	vec4 gbuffer2Val = texture(gbuffer2, UV);
	vec4 gbuffer3Val = texture(gbuffer3, UV);

	vec3 fragPos	= ViewPosFromDepth(gbuffer0Val.r, UV).rgb;
    fragPos.z       = LinearizeDepth(gbuffer0Val.r);
	vec3 normal		= gbuffer1Val.rgb;
    vec3 randomVec  = vec3(2 * texture(noiseTex, UV * noiseScale).xy - 1, 0); 

    vec3 tangent   = normalize(randomVec - normal * dot(randomVec, normal));
    vec3 bitangent = cross(normal, tangent);
    mat3 TBN       = mat3(tangent, bitangent, normal);
    
    float bias = 0.025;
    float radius = 0.6;
    float occlusion = 0.0;
    for(int i = 0; i < kernelSize; i++) {
        vec3 sampleKernel = TBN * kernels[i];
        sampleKernel = fragPos + sampleKernel * radius;

        vec4 offset = vec4(sampleKernel, 1.0);
        offset      = projection * offset;    // from view to clip-space
        offset.xyz /= offset.w;               // perspective divide
        offset.xyz  = offset.xyz * 0.5 + 0.5; // transform to range 0.0 - 1.0 

        float sampleDepth = texture(gbuffer0, 1 - offset.xy).r;
        sampleDepth = LinearizeDepth(sampleDepth);
        float rangeCheck = (abs(fragPos.z - sampleDepth) < radius) ? 1.0 : 0.0;
        occlusion += (sampleDepth <= sampleKernel.z ? 1.0 : 0.0) * rangeCheck;
    }

    occlusion = 1.0 - (occlusion / kernelSize);
    output = occlusion;
}
#version 420 core

out vec3 colorOut;

uniform sampler2D gbuffer0;
uniform sampler2D gbuffer1;
uniform sampler2D gbuffer2;
uniform sampler2D gbuffer3;
uniform samplerCube texRefl;

uniform vec3 eyePos;

in vec2 UV;

#include ../shaders/light.is
#include ../shaders/decode.is

float computeLod(float roughness, uint numSamples, float NH) {
	float dist = Light_D(roughness, NH);
	return 0.5 * (log2(float(512*512)/numSamples) - log2(dist));
}

vec2 Hammersley(uint i, uint N) {
	return vec2(float(i) / float(N), float(bitfieldReverse(i)) * 2.328306436538693e-10);
}

vec3 MakeSample(vec2 E) {
	float SineTheta = sin(E.x);

	float x = cos(E.y) * SineTheta;
	float y = sin(E.y) * SineTheta;
	float z = cos(E.x);

	return vec3(x, y, z);
}

vec3 radiance(vec3 N, vec3 V, vec4 Specular) {
	vec3 UpVector = (abs(N.z) < 0.999) ? vec3(0,1,0) : vec3(1,0,0);
	vec3 TangentX = normalize(cross(UpVector, N));
	vec3 TangentY = cross(N, TangentX);

	float NV = abs(dot(N, V));

	float alpha = Specular.a;

	vec3 fColor = vec3(0);
	const uint NumSamples = uint(20);
	for (uint i = 0; i < NumSamples; i++) {
		vec2 Xi = Hammersley(i, NumSamples);
		vec3 Li = MakeSample(Xi);
		vec3 H = normalize(Li.x * TangentX + Li.y * TangentY + Li.z * N);
		vec3 L = normalize(-reflect(V, H));

		float NL = abs(dot(N, L));
		float NH = abs(dot(N, H));
		float VH = abs(dot(V, H));
		float lod = computeLod(alpha, NumSamples, NH);

		vec3 f0 = Specular.rgb;
		float f90 = clamp(50 * dot(f0, vec3(0.33)), 0, 1);
		vec3 F_ = Light_F(f0, f90, VH);
		float G_ = Light_V(NL, NV, alpha);

		vec3 LColor = textureLod(texRefl, L, lod).rgb;
		fColor += F_ * G_ * LColor;
	}

	return fColor / float(NumSamples);
}

void main() {

	vec4 gbuffer0Val = texture(gbuffer0, UV);
	vec4 gbuffer1Val = texture(gbuffer1, UV);
	vec4 gbuffer2Val = texture(gbuffer2, UV);
	vec4 gbuffer3Val = texture(gbuffer3, UV);

	vec3 Position	= WorldPosFromDepth(gbuffer0Val.r, UV);
	vec3 CamPos		= ViewPosFromDepth(gbuffer0Val.r, UV).xyz;
	vec3 Normal		= decodeNormal(gbuffer1Val.rgb);
	vec3 Albedo		= gbuffer2Val.rgb;
	vec4 Specular	= gbuffer3Val;

	if (gbuffer0Val.r == 1) {
		discard;
	}
	else {
		vec3 V	 = normalize(eyePos - Position.xyz);
		vec3 L	 = reflect(-V, Normal);

		float NV = clamp(dot(Normal, V), 0, 1);
		float NL = clamp(dot(Normal, L), 0, 1);

		vec3 irrMap = textureLod(texRefl, Normal, Specular.a).rgb;
		vec3 Kdiff = irrMap * Albedo / pi;
		vec3 Kspec = radiance(Normal, V, Specular);

		colorOut = Kdiff + Kspec; //CalculateIBL(Position.xyz, Normal.xyz, Specular);
	}

	colorOut = gbuffer2Val.w * vec3(1,0,0);
}
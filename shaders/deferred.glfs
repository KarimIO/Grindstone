#version 330 core

out vec3 color; // X Y Z MaterialType

uniform sampler2D texPos;
uniform sampler2D texNormal;
uniform sampler2D texAlbedo;
uniform sampler2D texSpecular;
uniform samplerCube texRefl;

uniform vec3 eyePos;

in vec2 UV;

const float pi = 3.14159;

// Schlick
vec3 Light_F(in vec3 f0, in float f90, in float VH) {
	return f0 + (f90-f0) * pow(1-VH, 5.0f);
}

// GGX
float Light_D(in float alphaSqr, in float NH) {
	float denom = NH * NH * (alphaSqr - 1) + 1;

	return alphaSqr / (pi * denom * denom);
}

float Light_V( in float NL, in float NV, in float alphaSqr ) {
	float Lambda_GGXV = NL * sqrt (( - NV * alphaSqr + NV ) * NV + alphaSqr );
	float Lambda_GGXL = NV * sqrt (( - NL * alphaSqr + NL ) * NL + alphaSqr );

	return 0.25f / ( Lambda_GGXV + Lambda_GGXL );
}

float Diff_Disney( float NdotV, float NdotL, float LdotH ,float linearRoughness ) {
	float energyBias = 0*(1-linearRoughness) + 0.5*linearRoughness;
	float energyFactor = 1.0*(1-linearRoughness) + linearRoughness / 1.51;
	float fd90 = energyBias + 2.0 * LdotH * LdotH * linearRoughness ;
	vec3 f0 = vec3(1.0f , 1.0f , 1.0f);
	float lightScatter = Light_F( f0 , fd90 , NdotL ) .r;
	float viewScatter = Light_F(f0 , fd90 , NdotV ).r;

	return lightScatter * viewScatter * energyFactor ;
}

vec3 BSDF(in vec3 Albedo, in vec3 Specular, in vec3 Normal, in vec3 lightDir, in float linearRoughness, in vec3 eyeDir) {	
	float Roughness = linearRoughness * linearRoughness;
	float alpha = Roughness * Roughness;
	float alphaSqr = alpha*alpha;
	
	vec3 H = normalize(eyeDir + lightDir);
	
	float NL = clamp(dot(Normal, lightDir), 0, 1);
	float NV = abs(dot(Normal, eyeDir));
	float NH = clamp(dot(Normal, H), 0, 1);
	float LH = clamp(dot(lightDir, H), 0, 1);
	float VH = clamp(dot(eyeDir, H), 0, 1);
	
	vec3 f0 = 0.32*Specular.rgb*Specular.rgb;
	float f90 = clamp(50 * f0.r * 0.33, 0, 1);
	
	float D = Light_D(alpha, NH);
	vec3 F = Light_F(f0, f90, LH);
	float Vis = Light_V(NL, NV, alpha);
	
	vec3 eyeReflect = reflect(-eyeDir, Normal.xyz);
	vec3 reflColor =  texture(texRefl, eyeReflect).rgb;

	vec3 Spec = (D * F * Vis) * reflColor;
	
	vec3 Diffuse = Albedo.rgb*vec3(Diff_Disney(NV ,NL , LH, linearRoughness))/pi;
	
	return (Diffuse + Spec);
}

vec3 LightCalc(in vec3 Albedo, in vec3 WorldPos, in vec4 Specular, in vec3 Normal, in vec3 lightPos, in float lightRadius, in vec4 lightColor, in vec3 eyePos) {
	vec3 lightDir	= WorldPos - lightPos;
	vec3 eyeDir		= normalize(eyePos - WorldPos);
	vec3 eyeReflect = reflect(-eyeDir, Normal);
	
	float Distance	= length(lightDir);
	lightDir		= -normalize(lightDir);
	
	float linRoughness = Specular.a;
	
	float NL = clamp(dot(Normal, lightDir), 0, 1);
	
	float Dist2 = Distance * Distance;
	float lrad2 = lightRadius * lightRadius;
	float factor = Dist2 / lrad2;
	float Attenuation = clamp(1 - factor * factor, 0, 1); 
	Attenuation = Attenuation*Attenuation/(Dist2+0.001);
	
	vec3 lightModifier = lightColor.xyz*lightColor.w * Attenuation;
	vec3 BSDFValue = BSDF(Albedo, Specular.rgb, Normal, lightDir, linRoughness, eyeDir);
	return NL * BSDFValue * lightModifier; // vec3(1-Distance/lightRadius); //
}

vec3 LightPointCalc(in vec3 Albedo, in vec3 WorldPos, in vec4 Specular, in vec3 Normal, in vec3 lightPos, in float lightRadius, in vec4 lightColor, in vec3 eyePos) {
	vec3 lightDir	= WorldPos - lightPos;
	float Distance	= length(lightDir);

	return LightCalc(Albedo, WorldPos, Specular, Normal, lightPos, lightRadius, lightColor, eyePos);
}

vec3 pow3(vec3 a, float b) {
	return vec3(pow(a.x, b), pow(a.y, b), pow(a.z, b));
}

vec3 accurateLinearToSRGB (vec3 linearCol ) {
	vec3 sRGBLo = linearCol * 12.92;
	vec3 sRGBHi = ( pow3( abs ( linearCol ) , 1.0/2.4) * 1.055) - 0.055;
	vec3 sRGB;
	sRGB.r = ( linearCol.r <= 0.0031308) ? sRGBLo.r : sRGBHi.r ;
	sRGB.g = ( linearCol.g <= 0.0031308) ? sRGBLo.g : sRGBHi.g ;
	sRGB.b = ( linearCol.b <= 0.0031308) ? sRGBLo.b : sRGBHi.b ;
	return sRGB;
}

vec3 CalculateIBL(vec3 WorldPos, vec3 Normal, vec4 Specular) {
	vec3 eyeDir		= normalize(eyePos - WorldPos.xyz);
	vec3 eyeReflect = reflect(-eyeDir, Normal);
	
	float Roughness = pow(Specular.a, 2);
	float alpha = Roughness * Roughness;
	
	float NV = abs(dot(Normal, eyeDir));
	
	vec3 reflectDir = normalize(eyeReflect);
	vec3 reflectPix = texture(texRefl, reflectDir).rgb;
		
	vec3 F = Light_F(Specular.rgb, 1, NV);
	float Vis = Light_V(1, NV, alpha);
	return F * Vis * reflectPix;
}

void main() {
	vec4 Position = texture(texPos, UV);
	vec4 Normal = texture(texNormal, UV);
	vec4 Albedo = texture(texAlbedo, UV);
	vec4 Specular = texture(texSpecular, UV);

	float lightRadius = 24;
	float lightPow = 5;
	color = CalculateIBL(Position.xyz, Normal.xyz, Specular);
	float sideDist = 4.5;
	for (int i=-1; i <=1; i++) {
		vec3 lightPos = vec3(10,1.5,i * sideDist);
		vec4 lightColor = vec4(0.83, 0.92, 1, lightPow);
		color += LightPointCalc(Albedo.rgb, Position.xyz, Specular, Normal.xyz, lightPos, lightRadius, lightColor, eyePos);

		lightPos = vec3(5,1.5,i * sideDist);
		lightColor = vec4(1, 0.95, 0.89, lightPow);
		color += LightPointCalc(Albedo.rgb, Position.xyz, Specular, Normal.xyz, lightPos, lightRadius, lightColor, eyePos);

		lightPos = vec3(0,1.5,i * sideDist);
		lightColor = vec4(0.95, 1, 0.98, lightPow);
		color += LightPointCalc(Albedo.rgb, Position.xyz, Specular, Normal.xyz, lightPos, lightRadius, lightColor, eyePos);

		lightPos = vec3(-5,1.5,i * sideDist);
		lightColor = vec4(0.83, 0.92, 1, lightPow);
		color += LightPointCalc(Albedo.rgb, Position.xyz, Specular, Normal.xyz, lightPos, lightRadius, lightColor, eyePos);

		lightPos = vec3(-10,1.5,i * sideDist);
		lightColor = vec4(1, 0.95, 0.89, lightPow);
		color += LightPointCalc(Albedo.rgb, Position.xyz, Specular, Normal.xyz, lightPos, lightRadius, lightColor, eyePos);
	}
	color = accurateLinearToSRGB(color);
}
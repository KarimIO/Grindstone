include "$ENGINE/pipelinesets/common/rendererUniform.gpset"

shaderBlock GsMeshRendererInstanceUbo {
	shaderHlsl {
		struct RenderInstanceUBO {
			float4x4 modelMatrix;
		};

		cbuffer renderInstanceUbo : register(b0, space2) { RenderInstanceUBO renderInstanceUbo; }
	}
}

shaderBlock GsMeshRendererVertexInput {
	shaderHlsl {
		struct VertexInput {
			[[vk::location(0)]] float4 position : POSITION0;
			[[vk::location(1)]] float3 normal : NORMAL0;
			[[vk::location(2)]] float3 tangent : TANGENT0;
			[[vk::location(3)]] float2 texCoord0 : TEXCOORD0;
		};
	}
}

shaderBlock GsMeshRendererVertexInput {
	requiresBlocks [
		GsMeshRendererVertexInput,
		GsRendererUniform,
		GsMeshRendererInstanceUbo
	]

	shaderHlsl {
		struct VertexToFragment {
			float4 position : SV_Position;
			[[vk::location(0)]] float3 normal : COLOR0;
			[[vk::location(1)]] float3 tangent : COLOR1;
			[[vk::location(2)]] float2 texCoord0 : TEXCOORD0;
		};

		VertexToFragment mainVertex(VertexInput input) {
			VertexToFragment output;

			float3x3 modelMat3 = (float3x3)renderInstanceUbo.modelMatrix;
			output.normal = mul(normalize(input.normal), modelMat3);
			output.tangent = mul(normalize(input.tangent), modelMat3);
			output.texCoord0 = input.texCoord0;

			output.position = mul(mul(mul(float4(input.position.xyz, 1.0), renderInstanceUbo.modelMatrix), rendererUbo.projectionMatrix), rendererUbo.viewMatrix);
			return output;
		}
	}
}

shaderBlock GsMeshRendererFragmentOutput {
	shaderHlsl {
		struct FragmentOutput {
			[[vk::location(0)]] float4 gbufferAlbedoMatrix : COLOR0;
			[[vk::location(1)]] float4 gbufferNormals : COLOR1;
			[[vk::location(2)]] float4 gbufferSpecularRoughness : COLOR2;
		};
	}
}

shaderBlock GsTransformNormalToWorldSpace {
	shaderHlsl {
		float3 TransformNormalToWorldSpace(float3 vertexNormalValue, float3 normalTextureSample, float3 vertexTangentValue) {
			float3 bumpMapNormal = normalTextureSample;
			if (all(normalTextureSample == float3(0, 0, 0))) {
				return vertexNormalValue;
			}

			float3 newNormal = normalize(vertexNormalValue);
			float3 newTangent = normalize(vertexTangentValue);
			newTangent = normalize(newTangent - dot(newTangent, newNormal) * newNormal);
			float3 bitangent = cross(newTangent, newNormal);
			bumpMapNormal = 2.0 * bumpMapNormal - float3(1.0, 1.0, 1.0);
			bumpMapNormal = float3(-bumpMapNormal.xy, bumpMapNormal.z);
			float3x3 tangentBitangentNormalMatrix = float3x3(newTangent, bitangent, newNormal);
			return normalize(mul(bumpMapNormal, tangentBitangentNormalMatrix));
		}
	}
}

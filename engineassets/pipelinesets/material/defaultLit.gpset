include "$ENGINE/pipelinesets/common/meshRenderer.gpset"
include "$ENGINE/pipelinesets/common/matrixTransformations.gpset"

pipelineSet "lit.default" {
	parameters {
		Color materialInstanceUbo.color : Color.white,
		Texture albedoTexture : Texture2D.missingCheckerboard,
		Texture normalTexture : Texture2D.missingNormal,
		Texture metalnessTexture : Texture2D.black,
		Texture roughnessTexture : Texture2D.black
	}

	configuration "main" {
		rendererTags: "deferred"

		pass "main" {
			shaderEntrypoint: vertex mainVertex
			shaderEntrypoint: fragment mainFragment
			renderQueue: "GeometryOpaque"

			properties {
				cull: back
				depthBias: 1.25, 1.75, 0.0
				depthWrite: true
				depthTest: true
				depthClamp: false
				depthCompareOp: lessOrEqual
				attachments: [
					{
						colorMask: rgba
						blendPreset: opaque
					},
					{
						colorMask: rgba
						blendPreset: opaque
					},
					{
						colorMask: rgba
						blendPreset: opaque
					}
				]
			}

			requiresBlocks [
				GsMeshRendererVertex,
				GsTransformNormalToWorldSpace
			]

			shaderHlsl {
				struct MaterialInstanceUBO {
					float4 color;
				};

				ConstantBuffer<MaterialInstanceUBO> materialInstanceUbo : register(b0, space1);

				SamplerState textureSampler : register(s1, space1);
				Texture2D<float4> albedoTexture : register(t2, space1);
				Texture2D<float4> normalTexture : register(t3, space1);
				Texture2D<float4> metalnessTexture : register(t4, space1);
				Texture2D<float4> roughnessTexture : register(t5, space1);

				struct FragmentOutput {
					[[vk::location(0)]] float4 gbufferAlbedoMatID : SV_TARGET0;
					[[vk::location(1)]] float4 gbufferNormal : SV_TARGET1;
					[[vk::location(2)]] float4 gbufferSpecularRoughness : SV_TARGET2;
				};

				FragmentOutput mainFragment(VertexToFragment input) {
					float4 albedo = float4(1, 0.8, 0.6, 1); // float4(materialInstanceUbo.color.rgb, 1) * albedoTexture.Sample(textureSampler, input.texCoord0);

					// float3 textureSpaceNormal = normalTexture.Sample(textureSampler, input.texCoord0).rgb;
					float metalness = 0.0f; // metalnessTexture.Sample(textureSampler, input.texCoord0).r;
					float roughness = 0.5; // roughnessTexture.Sample(textureSampler, input.texCoord0).r;

					float3 specular = lerp(float3(0.04, 0.04, 0.04), albedo.rgb, metalness);
					float3 worldSpaceNormal = normalize(input.normal); // TransformNormalToWorldSpace(input.normal, textureSpaceNormal, input.tangent);

					FragmentOutput output = (FragmentOutput)0;
					output.gbufferAlbedoMatID = albedo;
					output.gbufferNormal = float4(worldSpaceNormal, 1);
					output.gbufferSpecularRoughness = float4(specular, roughness);
					return output;
				}
			}
		}

		pass "shadowMap" {
			shaderEntrypoint: vertex mainShadowVertex
			shaderEntrypoint: fragment mainShadowFragment
			renderQueue: "ShadowMap"

			properties {
				cull: back
				depthBias: 1.25, 1.75, 0.0
				depthWrite: true
				depthTest: true
				depthClamp: false
				depthCompareOp: lessOrEqual
				attachments: []
			}

			requiresBlocks [
				GsMeshRendererVertexInput,
				GsRendererUniform,
				GsMeshRendererInstanceUbo
			]

			shaderHlsl {
				struct VertexToFragment {
					float4 position : SV_Position;
				};

				VertexToFragment mainShadowVertex(VertexInput input) {
					VertexToFragment output;

					float4 worldPos = mul(renderInstanceUbo.modelMatrix, float4(input.position.xyz, 1.0));
					float4 viewPos  = mul(rendererUbo.viewMatrix, worldPos);
					output.position = mul(rendererUbo.projectionMatrix, viewPos);

					return output;
				}

				void mainShadowFragment(VertexToFragment input) {
				}
			}
		}
	}
}

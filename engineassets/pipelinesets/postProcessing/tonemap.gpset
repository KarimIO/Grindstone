include "$ENGINE/pipelinesets/common/postProcessingTemplate.gpset"

pipelineSet "Tonemapping" inherits "PostProcessing" {
	configuration "main" {
		pass "main" {
			shaderEntrypoint: vertex mainVertex
			shaderEntrypoint: fragment mainFragment
			renderQueue: "Main"

			properties {
				cull: back
				depthBias: false
				depthWrite: false
				depthTest: false
				depthClamp: false
				depthCompareOp: lessOrEqual
				attachments: {
					colorMask: rgba
					blendPreset: opaque
				}
			}

			shaderHlsl {
				SamplerState gbufferSampler : register(s0, space2);
				Texture2D<float4> litSceneTexture : register(t1, space2);
				Texture2D<float4> bloomTexture : register(t2, space2);

				struct PostProcessUbo {
					float4 vignetteColor;
					float vignetteRadius;
					float vignetteSoftness;
					float grainAmount;
					float grainPixelSize;
					float2 chromaticDistortionRedOffset;
					float2 chromaticDistortionGreenOffset;
					float2 chromaticDistortionBlueOffset;
					float paniniDistortionStrength;
					bool isAnimated;
				};

				ConstantBuffer<PostProcessUbo> postProcessingUbo : register(b3, space2);

				float3 linearToSRGB(float3 inColor) {
					float3 outColor;
					outColor.r = inColor.r <= 0.0031308 ? 12.92 * inColor.r : 1.055 * pow(inColor.r, 1.0/2.4) - 0.055;
					outColor.g = inColor.g <= 0.0031308 ? 12.92 * inColor.g : 1.055 * pow(inColor.g, 1.0/2.4) - 0.055;
					outColor.b = inColor.b <= 0.0031308 ? 12.92 * inColor.b : 1.055 * pow(inColor.b, 1.0/2.4) - 0.055;
					return outColor;
				}

				float3 hdrTransform(float3 color) {
					float a = 2.51f;
					float b = 0.03f;
					float c = 2.43f;
					float d = 0.59f;
					float e = 0.14f;

					return clamp((color*(a*color+b))/(color*(c*color+d)+e), 0, 1);
				}

				float4 mainFragment(VertexToFragment input) : SV_TARGET0 {
					float3 sceneColor = litSceneTexture.SampleLevel(gbufferSampler, input.scaledFragmentTexCoord, 0.0).rgb;

					return float4(sceneColor, 1);
				}
			}
		}
	}
}
